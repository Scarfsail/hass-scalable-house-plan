# Performance Degradation Over Time - Analysis

**Date:** 2026-02-20
**Scope:** Full lifecycle review of `scalable-house-plan` and all related components

---

## Summary

The card gets slower over time due to a combination of **unbounded cache growth**, **redundant re-renders on every HA state update**, and a **permanent global document listener accumulation** in the action-handler. The issues compound: the more entities HA updates, the more re-renders occur; the more the user zooms, the more cache entries accumulate. None of the caches are ever evicted.

---

## Issue 1 — `HouseCache.position` Grows Unbounded with Zoom (HIGH SEVERITY)

**File:** `src/components/element-renderer-shp.ts` · `src/cards/scalable-house-plan.ts`

The position cache (`houseCache.position`) is a `Map<string, PositionCache>` stored on the `HouseCache` instance owned by the root card. Cache keys are generated by `getPositionCacheKey()`:

```ts
// src/components/element-renderer-shp.ts:255-259
function getPositionCacheKey(uniqueKey, scale, scaleRatio, boundsKey, plan): string {
    const positionKey = `${plan.left}-${plan.top}-...`;
    return `${uniqueKey}-${scale.toFixed(2)}-${scaleRatio}-${boundsKey}-${positionKey}-...`;
}
```

The `scale.toFixed(2)` component means every distinct zoom level creates a **new cache entry that is never evicted**. A user who pinch-zooms actively will generate hundreds of entries. With N elements × M unique zoom levels the Map grows to N×M entries and is never trimmed.

`HouseCache` is also shared between the overview and all room instances, so entries from all views accumulate in a single Map. The `elementMetadata` and `elementStructure` Maps on `HouseCache` are defined but never written to (dead code weight).

**Effect:** Linear memory growth correlated with user zooming activity. Cache lookups in a large Map are O(1) but GC pressure increases due to retained string keys and cached objects.

---

## Issue 2 — Every HA State Update Re-Renders All Rooms (HIGH SEVERITY)

**File:** `src/components/scalable-house-plan-room.ts:139-141`

```ts
if (changedProperties.has('hass')) {
    this._updateDynamicColor();
}
```

HA calls the `hass` setter on the root card on **every state change of any entity in the system** (not just entities in the room). This propagates to every `scalable-house-plan-room` instance, which calls `_updateDynamicColor()`. That function:

1. Calls `calculateDynamicRoomColor()` — iterates motion sensors with `Date.now()` timestamp arithmetic
2. Calls `calculatePolygonCenter()` — sum/divide over all boundary points
3. Calls `createGradientDefinition()` once or twice — creates new `GradientDefinition` objects

The result is assigned to `@state()` properties:

```ts
// src/components/scalable-house-plan-room.ts:309-370
this._currentColor = calculateDynamicRoomColor(...);   // new object
this._currentGradient = createGradientDefinition(...); // new object
this._currentGradientInverted = createGradientDefinition(...); // new object
```

Because these are always new object references (even when the logical values haven't changed), LitElement's `@state()` always considers them changed, always scheduling a re-render of the room. With 10 rooms, every HA entity update causes **10 room re-renders**, each producing new gradient objects.

HA typically batches updates but can fire multiple per second. This is the primary cause of "gets slower the longer it runs" — the cumulative render cost grows with the number of active rooms and the frequency of unrelated entity updates.

---

## Issue 3 — `buildElementStructure` Runs Uncached on Every Render (HIGH SEVERITY)

**File:** `src/components/element-renderer-shp.ts:762-763`

```ts
// Intentionally not cached (comment in source)
const elements = buildElementStructure(room.entities || [], hass, roomIndex, elementDefaults);
```

This is called on every call to `renderElements()`, which happens on every render of every room. `buildElementStructure` calls:

- `buildElementMetadata()` per element → calls `getElementTypeForEntity()`, `mergeElementProperties()`, `getDefaultTapAction()`, `isEntityActionable()`
- Object spread operations for three-tier config merge

For the `info-box` element type, `getAllRoomEntityIds()` is called additionally per info-box per render:

```ts
// element-renderer-shp.ts:769
el.elementConfig.room_entities = getAllRoomEntityIds(hass, roomForInfoBox, null);
```

With N rooms × M elements × frequency of HA updates, this is a substantial amount of repeated work. The existing comment acknowledges this is intentional (to avoid stale drag positions), but it means there is no fast path for the common case where nothing relevant has changed.

---

## Issue 4 — `ActionHandlerController` Adds Permanent `document` Listeners That Never Grow But Never Leave (MEDIUM SEVERITY)

**File:** `src/utils/action-handler.ts:40-79`

```ts
// Module-level singleton
const controller = new ActionHandlerController();
```

The constructor attaches **8 event listeners to `document`** (touchcancel, mouseout, mouseup, mousewheel, wheel, scroll, touchmove, mousemove). These are never removed — there is no `detach()` or cleanup method on the singleton.

```ts
// action-handler.ts:40-79 — listeners registered once, never cleaned up
['touchcancel', 'mouseout', 'mouseup', 'mousewheel', 'wheel', 'scroll'].forEach((ev) => {
    document.addEventListener(ev, () => { ... }, { passive: true });
});
document.addEventListener('touchmove', ...);
document.addEventListener('mousemove', ...);
```

The `mousemove` listener does work on every mouse move (checks distance threshold) even when no hold timer is active — this is a hot path with no early-exit guard for the case where no interaction is in progress. The `if (!this.timer) return;` guard is present but only for the compute-heavy section, not for the entire handler.

The `contextmenu` listener added in `bind()` uses an anonymous arrow function that cannot be removed:

```ts
// action-handler.ts:91-103
element.addEventListener('contextmenu', (ev: Event) => { ... }); // stored nowhere, unremovable
```

This listener is only added when `element.actionHandler` is falsy (first bind). Polygon elements can be recreated (when switching between motion/static state branches in the SVG template), which creates a new element without `.actionHandler`, causing a new unremovable `contextmenu` listener to be added. Old elements are detached from DOM so their listeners are GC'd — but this pattern means contextmenu listeners accumulate per element lifetime, not per session.

---

## Issue 5 — `subscribeRenderTemplate` Return Value (Unsubscribe Function) Is Never Stored (MEDIUM — Latent Leak)

**File:** `src/elements/base/element-base.ts:44-55`

```ts
protected async subscribeRenderTemplate(template: string, onChange: (result: string) => void) {
    // ...
    await subscribeRenderTemplate(this.hass.connection, template, onChange);
    // Return value (unsubscribe fn) is discarded!
}
```

The `subscribeRenderTemplate` in `hass-templates.ts` returns an `unsubscribe` function that must be called to close the WebSocket subscription. The wrapper in `element-base.ts` silently discards it. If any element calls `this.subscribeRenderTemplate()`, the HA WebSocket subscription will remain open indefinitely after the element is removed from DOM, receiving callbacks that call `onChange` on a disconnected component.

Currently, no element in this codebase appears to call `this.subscribeRenderTemplate()` in practice, so this is a latent bug. If a future element uses it, it would create unbounded subscription growth.

---

## Issue 6 — `requestUpdate()` Called Inside `willUpdate()` and Inside `render()` (MEDIUM)

**File:** `src/cards/scalable-house-plan-overview.ts:67-69`

```ts
willUpdate() {
    if (hasViewportChanged(this.previousViewport)) {
        this.requestUpdate(); // Called inside willUpdate!
    }
    // ...
}
```

**File:** `src/cards/scalable-house-plan-detail.ts:198-200`

```ts
render() {
    // ...
    if (hasViewportChanged(this.previousViewport)) {
        this.requestUpdate(); // Called inside render!
    }
    // ...
}
```

Calling `requestUpdate()` from inside `willUpdate()` schedules an immediate follow-up render cycle. In the detail view, it's called from `render()` which is worse — during rendering Lit's update microtask, scheduling another update creates an extra cycle every time the viewport changes. Both occurrences are at minimum wasteful; the one in `render()` could contribute to jank on window resize events.

---

## Issue 7 — `onResize` Has No Debouncing (MEDIUM)

**File:** `src/cards/scalable-house-plan.ts:389-395, 407-409`

```ts
connectedCallback() {
    // ...
    this.resizeObserver.observe(element);  // observes HA root div
}

onResize() {
    this.requestUpdate(); // no debouncing
}
```

The `ResizeObserver` fires continuously during window resize. Each callback calls `requestUpdate()` with no debounce. On modern browsers ResizeObserver batches within a frame, but still — during a window drag this fires ~60 times/second, each triggering a full re-render of the card and all its children.

---

## Issue 8 — Module-Level Maps in `element-renderer-shp.ts` Accumulate State (LOW-MEDIUM)

**File:** `src/components/element-renderer-shp.ts:24-44`

```ts
const dragControllers = new Map<string, DragController>();
const dragControllerRoomIndex = new Map<string, number>();
const currentKeysPerRoom = new Map<number, Set<string>>();
const previousKeysPerRoomView = new Map<string, Set<string>>();
```

These module-level Maps are only populated in editor mode, so they don't affect normal runtime. However:

- Entries for rooms/views that no longer exist are never removed from `currentKeysPerRoom` and `previousKeysPerRoomView`. When rooms are deleted from config, their room index entries remain indefinitely.
- If the editor is opened and closed repeatedly, entries accumulate. The cleanup logic only removes controllers whose `uniqueKey` is no longer in the current render, not for rooms that no longer exist entirely.
- `dragControllers` is cleaned up by `cleanupDragControllers()`, but this function is never called in the codebase — it's an exported utility with no caller.

---

## Issue 9 — `DragController.handlePointerMove` Walks the DOM on Every Pointer Move (LOW-MEDIUM)

**File:** `src/utils/drag-controller.ts:182-214`

```ts
public handlePointerMove = (e: PointerEvent): void => {
    // ...
    let element: HTMLElement | null = this.wrapper;
    for (let i = 0; i < 20 && element; i++) {
        // walk up DOM tree crossing shadow boundaries
        const transform = window.getComputedStyle(element).transform;
        // ...
    }
};
```

During drag, every `pointermove` event (which fires at pointer rate, up to 240Hz on some devices) walks up to 20 DOM ancestors, calling `window.getComputedStyle()` on each. `getComputedStyle` is a layout-triggering operation. While this only occurs during active drags (editor mode), it's still an expensive hot path.

---

## Issue 10 — `_updateDynamicColor` Has No Equality Check Before Triggering State Update (LOW-MEDIUM)

**File:** `src/components/scalable-house-plan-room.ts:305-371`

Even when the room state hasn't changed (lights still on, no motion), `_updateDynamicColor()` creates new `DynamicColorResult` and `GradientDefinition` objects and assigns them to `@state()` properties. A simple equality check (e.g., comparing `color` string and `type` string before creating gradient objects) could avoid the majority of re-renders.

```ts
// Current: always creates new objects
this._currentColor = calculateDynamicRoomColor(...); // new object reference → always triggers re-render
this._currentGradient = createGradientDefinition(...); // new object → always triggers re-render
```

---

## Issue 11 — `ScalableHousePlanDetail._calculateEntitiesNotOnDetail` Runs on Every Room Change (LOW)

**File:** `src/cards/scalable-house-plan-detail.ts:131-152`

```ts
updated(changedProperties) {
    if (changedProperties.has('room')) {
        this._elementCards.clear();
        this._calculateEntitiesNotOnDetail(); // calls getAreaEntities + getEntitiesNotOnDetailCount
    }
}
```

`getAreaEntities` iterates all HA entities. This is called every time a room is opened. Not a per-second issue, but the result is stored in `@state()` which triggers an additional re-render after the first render.

---

## Issue 12 — GPU Layer Proliferation from CSS Animations and `translateZ(0)` Hints (LOW)

**File:** `src/components/scalable-house-plan-room.ts` (styles)

```css
.elements-container {
    transform: translateZ(0);
    -webkit-transform: translateZ(0);
    backface-visibility: hidden;
}

.room-svg {
    backface-visibility: hidden;
    transform: translateZ(0);
}
```

Each room has two elements with GPU layer promotion hints. With motion active, two CSS-animated polygons per room add additional compositing layers. With many rooms (10+), this creates 20+ GPU compositing layers. Over time, if rooms cycle between motion/static states, the layer tree is rebuilt repeatedly. Browser GPU memory for compositing layers is not always returned promptly.

---

## Root Cause Ranking

| # | Issue | Category | Gets Worse Over Time? |
|---|-------|----------|-----------------------|
| 1 | Position cache grows with zoom | Memory leak | Yes — with zoom |
| 2 | Re-render all rooms on any HA update | Render thrashing | Yes — with entity count |
| 3 | `buildElementStructure` uncached | CPU overhead | Yes — with entity count |
| 4 | Permanent document listeners | Memory overhead | No — fixed size |
| 5 | `subscribeRenderTemplate` leak | WebSocket leak | Yes — if triggered |
| 6 | `requestUpdate` in `willUpdate`/`render` | Extra render cycles | No — fixed overhead |
| 7 | No resize debounce | CPU spikes | No — event-driven |
| 8 | Module-level maps accumulate | Memory | Yes — with editor use |
| 9 | DOM walk on pointer move | CPU during drag | No — editor only |
| 10 | No equality check before state update | Render thrashing | Yes — with hass frequency |
| 11 | `getAreaEntities` on room open | CPU on room open | No — one-shot |
| 12 | GPU layer proliferation | GPU memory | Yes — with room count |

---

## Recommended Fixes (Priority Order)

1. **Add memoization to `_updateDynamicColor`**: Compare previous `color + type` string before creating gradient objects. Only create new gradient objects when color type actually changes. This fixes Issues 2 and 10.

2. **Add LRU or size-capped eviction to `houseCache.position`**: After N entries (e.g., 500), evict oldest. Alternatively, clear the cache when scale stabilizes (after zoom ends). This fixes Issue 1.

3. **Add unsubscribe storage to `subscribeRenderTemplate`**: Store the returned function and call it in `disconnectedCallback`. This fixes Issue 5.

4. **Debounce `onResize`**: Wrap with a 100–150ms debounce. This fixes Issue 7.

5. **Fix `requestUpdate` in `willUpdate`/`render`**: Move viewport-change detection to `connectedCallback` (add a ResizeObserver on self) or handle it differently. This fixes Issue 6.

6. **Add early exit to `ActionHandlerController.mousemove`**: Add `if (!this.timer && !this.held) return;` at the very top to skip all work when no interaction is in progress.

7. **Call `cleanupDragControllers()` in the root card's `disconnectedCallback`** and when editor mode is disabled. Also clean up `previousKeysPerRoomView` entries for removed rooms. This fixes Issue 8.
